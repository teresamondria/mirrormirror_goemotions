// Mock the transcriptCache
const mockTranscriptCache: { [key: string]: { transcript: string; timestamp: number } } = {};

// Mock the module
jest.mock('../transcriptGenerator', () => {
  return {
    generateTranscript: jest.fn().mockImplementation(async (...args: unknown[]) => {
      const videoId = args[0] as string;
      // Mock successful OpenAI API response
      const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: 'whisper-1',
          url: `https://www.youtube.com/watch?v=${videoId}`
        })
      });

      if (!response.ok) {
        throw new Error('Failed to generate transcript');
      }

      const data = await response.json();
      const transcript = data.text;

      // Cache the generated transcript
      mockTranscriptCache[videoId] = {
        transcript,
        timestamp: Date.now()
      };

      return transcript;
    }),
    transcriptCache: mockTranscriptCache
  };
});

import { describe, expect, test, beforeEach, jest } from '@jest/globals';
import { generateTranscript } from '../transcriptGenerator';

// Test video ID
const TEST_VIDEO_ID = 'dQw4w9WgXcQ';

// Mock transcript data
const MOCK_TRANSCRIPT = 'This is a test transcript generated by OpenAI';

describe('Transcript Generator', () => {
  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
    // Clear the transcript cache
    Object.keys(mockTranscriptCache).forEach(key => delete mockTranscriptCache[key]);
  });

  test('should generate transcript successfully', async () => {
    // Mock successful OpenAI API response
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          text: MOCK_TRANSCRIPT
        })
      });
    }) as any;

    const result = await generateTranscript(TEST_VIDEO_ID);
    expect(result).toBe(MOCK_TRANSCRIPT);
    expect(mockTranscriptCache[TEST_VIDEO_ID]).toBeDefined();
    expect(mockTranscriptCache[TEST_VIDEO_ID].transcript).toBe(MOCK_TRANSCRIPT);
  });

  test('should handle API errors', async () => {
    // Mock failed OpenAI API response
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: false,
        statusText: 'API Error'
      });
    }) as any;

    await expect(generateTranscript(TEST_VIDEO_ID)).rejects.toThrow('Failed to generate transcript');
    expect(mockTranscriptCache[TEST_VIDEO_ID]).toBeUndefined();
  });

  test('should handle network errors', async () => {
    // Mock network error
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.reject(new Error('Network Error'));
    }) as any;

    await expect(generateTranscript(TEST_VIDEO_ID)).rejects.toThrow('Network Error');
    expect(mockTranscriptCache[TEST_VIDEO_ID]).toBeUndefined();
  });

  test('should cache generated transcript', async () => {
    // Mock successful OpenAI API response
    global.fetch = jest.fn().mockImplementation(() => {
      return Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          text: MOCK_TRANSCRIPT
        })
      });
    }) as any;

    const result = await generateTranscript(TEST_VIDEO_ID);
    expect(result).toBe(MOCK_TRANSCRIPT);
    
    // Verify cache entry
    expect(mockTranscriptCache[TEST_VIDEO_ID]).toBeDefined();
    expect(mockTranscriptCache[TEST_VIDEO_ID].transcript).toBe(MOCK_TRANSCRIPT);
    expect(mockTranscriptCache[TEST_VIDEO_ID].timestamp).toBeLessThanOrEqual(Date.now());
  });
}); 